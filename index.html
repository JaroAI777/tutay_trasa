<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Najkrótsza trasa piesza (OSM) — 10–12 adresów</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* Czytelna kolorystyka w trybie jasnym i ciemnym */
    :root {
      color-scheme: light dark;
      --bg: #ffffff;
      --fg: #0b0f19;
      --muted: rgba(11, 15, 25, 0.72);
      --muted2: rgba(11, 15, 25, 0.55);
      --line: rgba(11, 15, 25, 0.16);
      --panel: #ffffff;
      --inputBg: #ffffff;
      --inputFg: #0b0f19;
      --inputPh: rgba(11, 15, 25, 0.45);
      --btnBg: rgba(11, 15, 25, 0.06);
      --btnBgPrimary: rgba(0, 120, 255, 0.14);
      --btnFg: #0b0f19;
      --chipBg: rgba(11, 15, 25, 0.06);
      --warn: #b45309;
      --err: #b91c1c;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0f19;
        --fg: #e8ecf7;
        --muted: rgba(232, 236, 247, 0.78);
        --muted2: rgba(232, 236, 247, 0.58);
        --line: rgba(232, 236, 247, 0.18);
        --panel: #0e1424;
        --inputBg: #0a1020;
        --inputFg: #e8ecf7;
        --inputPh: rgba(232, 236, 247, 0.45);
        --btnBg: rgba(232, 236, 247, 0.08);
        --btnBgPrimary: rgba(0, 120, 255, 0.24);
        --btnFg: #e8ecf7;
        --chipBg: rgba(232, 236, 247, 0.08);
        --warn: #f59e0b;
        --err: #ef4444;
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .app {
      display: grid;
      grid-template-columns: 420px 1fr;
      height: 100vh;
      gap: 0;
    }

    .panel {
      padding: 16px;
      background: var(--panel);
      border-right: 1px solid var(--line);
      overflow: auto;
    }

    .map { height: 100vh; }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 12px 0 6px;
    }

    input[type="text"], select, textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: var(--inputBg);
      color: var(--inputFg);
      outline: none;
    }

    input[type="text"]::placeholder,
    textarea::placeholder {
      color: var(--inputPh);
    }

    textarea { min-height: 210px; resize: vertical; }

    .row { display: flex; gap: 10px; }
    .row > * { flex: 1; }

    .btnrow { display: flex; gap: 10px; margin-top: 12px; }

    button {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      background: var(--btnBg);
      color: var(--btnFg);
    }

    button.primary {
      background: var(--btnBgPrimary);
      border-color: rgba(0, 120, 255, 0.45);
    }

    button:disabled { opacity: .55; cursor: not-allowed; }

    .hint { font-size: 12px; color: var(--muted2); line-height: 1.4; margin-top: 8px; }

    .status {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--chipBg);
      font-size: 12px;
      white-space: pre-wrap;
      min-height: 44px;
      color: var(--fg);
    }

    .result {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--chipBg) 70%, transparent);
    }

    .result h3 { margin: 0 0 8px; font-size: 14px; color: var(--fg); }
    .result ol { margin: 0 0 0 18px; padding: 0; }
    .result li { margin: 6px 0; font-size: 13px; color: var(--fg); }

    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .kpi .box {
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--chipBg);
    }

    .kpi .label { font-size: 12px; color: var(--muted); margin: 0; }
    .kpi .value { font-size: 16px; margin: 4px 0 0; font-weight: 650; color: var(--fg); }

    .footer { margin-top: 14px; font-size: 12px; color: var(--muted2); line-height: 1.35; }

    @media (max-width: 920px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      .panel { border-right: none; border-bottom: 1px solid var(--line); }
      .map { height: 60vh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h2 style="margin:0 0 6px; font-size:16px;">Najkrótsza trasa piesza (OpenStreetMap)</h2>
      <div class="hint">
        Wpisz miasto oraz 10–12 adresów (po jednym w wierszu). Aplikacja geokoduje adresy, wyznacza najkrótszą kolejność przejścia pieszo i rysuje trasę na mapie.
      </div>

      <div class="row">
        <div>
          <label for="city">Miasto</label>
          <input id="city" type="text" placeholder="np. Wrocław" value="Wrocław" />
        </div>
        <div>
          <label for="geocoder">Geokoder</label>
          <select id="geocoder">
            <option value="nominatim">Nominatim (OSM)</option>
            <option value="photon">Photon (komoot)</option>
            <option value="auto" selected>Auto (Nominatim → Photon)</option>
          </select>
        </div>
      </div>

      <label for="addresses">Adresy (10–12 linii)</label>
      <textarea id="addresses" placeholder="Rynek 1\nul. Świdnicka 8\n...">Rynek 1
plac Solny 1
ul. Świdnicka 8
ul. Piłsudskiego 105
ul. Grodzka 11
ul. Katedralna 4
ul. Wita Stwosza 32
ul. Kazimierza Wielkiego 35
ul. Kuźnicza 21
ul. Odrzańska 1</textarea>

      <div class="row">
        <div>
          <label for="router">Routing (pieszo)</label>
          <select id="router">
            <option value="osrm_fossgis" selected>OSRM (FOSSGIS) — routed-foot</option>
          </select>
        </div>
        <div>
          <label for="startMode">Punkt startu</label>
          <select id="startMode">
            <option value="free" selected>Dowolny (najszybsza całość)</option>
            <option value="fixed">Pierwszy adres jako start</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="btnExample" type="button">Wczytaj przykład</button>
        <button id="btnRun" class="primary" type="button">Oblicz trasę</button>
      </div>

      <div id="status" class="status">Gotowe.</div>

      <div id="result" class="result" style="display:none;">
        <h3>Wynik</h3>
        <div class="kpi">
          <div class="box">
            <p class="label">Czas (pieszo)</p>
            <p id="kpiTime" class="value">—</p>
          </div>
          <div class="box">
            <p class="label">Dystans</p>
            <p id="kpiDist" class="value">—</p>
          </div>
        </div>
        <div style="margin-top: 10px;">
          <ol id="order"></ol>
        </div>
      </div>

      <div class="footer">
        Mapy: © OpenStreetMap contributors (ODbL). Routing i geokodowanie opierają się na usługach publicznych, które mogą ograniczać intensywne użycie.
      </div>
    </div>

    <div id="map" class="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ====== Konfiguracja usług ======
    const NOMINATIM_BASE = "https://nominatim.openstreetmap.org";
    const PHOTON_BASE    = "https://photon.komoot.io";
    const OSRM_FOSSGIS_FOOT_BASE = "https://routing.openstreetmap.de/routed-foot";
    const OSRM_PROFILE = "walking";

    // Respektowanie limitów usług publicznych (w praktyce: geokodowanie 1 req/s).
    const GEOCODE_DELAY_MS = 1100;

    // ====== UI helpers ======
    const $ = (id) => document.getElementById(id);
    const statusEl = $("status");
    const btnRun = $("btnRun");
    const btnExample = $("btnExample");

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function sleep(ms) { return new Promise((r) => setTimeout(r, ms)); }

    function fmtTime(sec) {
      if (!isFinite(sec)) return "—";
      sec = Math.max(0, Math.round(sec));
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      return h > 0 ? `${h}h ${String(m).padStart(2, "0")}m` : `${m}m`;
    }

    function fmtDist(meters) {
      if (!isFinite(meters)) return "—";
      return `${(meters / 1000).toFixed(2)} km`;
    }

    function parseAddresses(text) {
      return String(text)
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean);
    }

    function normalizeQuery(s) {
      // Uwaga: poprzednia wersja miała niewidoczne znaki (TAB/CR) wewnątrz literału RegExp,
      // co mogło powodować: "Invalid regular expression: missing /".
      // Tu używamy jawnych sekwencji \t \r \n.
      return String(s)
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .replace(/[ \t\r\n]+/g, " ")
        .trim();
    }

    function withinBounds(lat, lon, bounds) {
      if (!bounds) return true;
      const { south, north, west, east } = bounds;
      return lat >= south && lat <= north && lon >= west && lon <= east;
    }

    function boundsToPhotonBbox(bounds) {
      // Photon: bbox=minLon,minLat,maxLon,maxLat
      return `${bounds.west},${bounds.south},${bounds.east},${bounds.north}`;
    }

    function boundsToNominatimViewbox(bounds) {
      // Nominatim: viewbox=left,top,right,bottom => west,north,east,south
      return `${bounds.west},${bounds.north},${bounds.east},${bounds.south}`;
    }

    async function safeReadJson(resp) {
      const ct = (resp.headers.get("content-type") || "").toLowerCase();
      try {
        if (ct.includes("application/json")) return await resp.json();
        const t = await resp.text();
        return { _text: t };
      } catch {
        return { _readError: true };
      }
    }

    // ====== Geokodowanie ======
    async function getCityBoundsNominatim(city) {
      // Ustalamy bbox miasta raz i używamy go do wszystkich przystanków.
      const c = normalizeQuery(city);
      const url = new URL(NOMINATIM_BASE + "/search");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("limit", "1");
      url.searchParams.set("q", c);

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.error || body.message || body._text) ? ` | ${body.error || body.message || body._text}` : "";
        throw new Error(`Nominatim(city) HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      if (!Array.isArray(data) || data.length === 0) throw new Error("Nominatim(city): brak wyników");

      const top = data[0];
      const bb = top.boundingbox;
      if (!Array.isArray(bb) || bb.length !== 4) throw new Error("Nominatim(city): brak boundingbox");

      // jsonv2: [south, north, west, east]
      const south = parseFloat(bb[0]);
      const north = parseFloat(bb[1]);
      const west  = parseFloat(bb[2]);
      const east  = parseFloat(bb[3]);

      if (![south, north, west, east].every(v => Number.isFinite(v))) {
        throw new Error("Nominatim(city): nieprawidłowy boundingbox");
      }
      if (!(south <= north && west <= east)) {
        throw new Error("Nominatim(city): odwrócony boundingbox");
      }

      return {
        south, north, west, east,
        display: top.display_name || c,
        lat: parseFloat(top.lat),
        lon: parseFloat(top.lon),
      };
    }

    async function geocodeNominatim(query, bounds /* optional */) {
      const q = normalizeQuery(query);
      if (!q) throw new Error("Nominatim: pusty query");

      const url = new URL(NOMINATIM_BASE + "/search");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("limit", "1");
      url.searchParams.set("q", q);

      // Ograniczenie wyszukiwania do granic miasta (jeżeli znane).
      if (bounds) {
        url.searchParams.set("viewbox", boundsToNominatimViewbox(bounds));
        url.searchParams.set("bounded", "1");
      }

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.error || body.message || body._text) ? ` | ${body.error || body.message || body._text}` : "";
        throw new Error(`Nominatim HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      if (!Array.isArray(data) || data.length === 0) throw new Error("Nominatim: brak wyników");

      const top = data[0];
      const out = {
        provider: "nominatim",
        display: top.display_name || q,
        lat: parseFloat(top.lat),
        lon: parseFloat(top.lon),
      };

      if (bounds && !withinBounds(out.lat, out.lon, bounds)) {
        throw new Error("Nominatim: wynik poza granicami miasta (sprawdź nazwę miasta)");
      }

      return out;
    }

    async function geocodePhoton(query, bounds /* optional */) {
      const q = normalizeQuery(query);
      if (!q) throw new Error("Photon: pusty query");

      const url = new URL(PHOTON_BASE + "/api/");
      url.searchParams.set("q", q);
      url.searchParams.set("limit", "1");

      // Ograniczenie do bbox miasta, jeśli znamy granice.
      if (bounds) {
        url.searchParams.set("bbox", boundsToPhotonBbox(bounds));
      }

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const msg = (body && (body.message || body.error)) ? (body.message || body.error) : (body && body._text ? body._text : "");
        const extra = msg ? ` | ${msg}` : "";
        throw new Error(`Photon HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();

      const f = (data && data.features && data.features[0]) || null;
      if (!f || !f.geometry || !Array.isArray(f.geometry.coordinates)) throw new Error("Photon: brak wyników");

      const [lon, lat] = f.geometry.coordinates;
      const props = f.properties || {};
      const display = [props.name, props.street, props.city, props.country].filter(Boolean).join(", ") || q;

      const out = {
        provider: "photon",
        display,
        lat: parseFloat(lat),
        lon: parseFloat(lon),
      };

      if (bounds && !withinBounds(out.lat, out.lon, bounds)) {
        throw new Error("Photon: wynik poza granicami miasta (sprawdź nazwę miasta)");
      }

      return out;
    }

    async function geocodeAuto(query, bounds /* optional */) {
      try {
        return await geocodeNominatim(query, bounds);
      } catch (e1) {
        try {
          return await geocodePhoton(query, bounds);
        } catch (e2) {
          throw new Error(
            `Geokodowanie nie powiodło się (Nominatim + Photon).\n` +
            `- Nominatim: ${e1 && e1.message ? e1.message : String(e1)}\n` +
            `- Photon: ${e2 && e2.message ? e2.message : String(e2)}`
          );
        }
      }
    }

    async function geocodeOne(addr, city, mode, bounds /* optional */) {
      const a = normalizeQuery(addr);
      const c = normalizeQuery(city);
      const q = a.toLowerCase().includes(c.toLowerCase()) ? a : `${a}, ${c}`;

      if (mode === "nominatim") return await geocodeNominatim(q, bounds);
      if (mode === "photon") return await geocodePhoton(q, bounds);
      return await geocodeAuto(q, bounds);
    }

    // ====== OSRM (macierz + trasa) ======
    async function osrmTable(coordsLonLat) {
      const coordStr = coordsLonLat.map(([lon, lat]) => `${lon.toFixed(6)},${lat.toFixed(6)}`).join(";");
      const url = new URL(`${OSRM_FOSSGIS_FOOT_BASE}/table/v1/${OSRM_PROFILE}/${coordStr}`);
      url.searchParams.set("annotations", "duration,distance");

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.message || body._text) ? ` | ${body.message || body._text}` : "";
        throw new Error(`OSRM /table HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      if (!data || !Array.isArray(data.durations)) throw new Error("OSRM: brak macierzy durations");
      return data;
    }

    async function osrmRouteOrdered(coordsLonLat) {
      const coordStr = coordsLonLat.map(([lon, lat]) => `${lon.toFixed(6)},${lat.toFixed(6)}`).join(";");
      const url = new URL(`${OSRM_FOSSGIS_FOOT_BASE}/route/v1/${OSRM_PROFILE}/${coordStr}`);
      url.searchParams.set("overview", "full");
      url.searchParams.set("geometries", "geojson");
      url.searchParams.set("steps", "false");

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.message || body._text) ? ` | ${body.message || body._text}` : "";
        throw new Error(`OSRM /route HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      const r = (data && data.routes && data.routes[0]) || null;
      if (!r || !r.geometry || !Array.isArray(r.geometry.coordinates)) throw new Error("OSRM: brak geometrii trasy");
      return {
        distance: r.distance,
        duration: r.duration,
        line: r.geometry.coordinates, // [lon,lat]
      };
    }

    // ====== Optymalizacja kolejności (DP TSP, ścieżka bez powrotu) ======
    function solveOpenPathTsp(durations, fixedStartIndex /* null|number */) {
      const n = durations.length;
      const INF = 1e18;

      const w = Array.from({ length: n }, (_, i) =>
        Array.from({ length: n }, (_, j) => {
          const v = durations[i][j];
          if (i === j) return 0;
          if (v === null || v === undefined) return INF;
          return Number(v);
        })
      );

      const size = 1 << n;
      const dp = Array.from({ length: size }, () => new Float64Array(n).fill(INF));
      const parent = Array.from({ length: size }, () => new Int16Array(n).fill(-1));

      if (fixedStartIndex === null) {
        for (let i = 0; i < n; i++) dp[1 << i][i] = 0;
      } else {
        dp[1 << fixedStartIndex][fixedStartIndex] = 0;
      }

      for (let mask = 0; mask < size; mask++) {
        for (let j = 0; j < n; j++) {
          const cur = dp[mask][j];
          if (!(cur < INF)) continue;
          for (let k = 0; k < n; k++) {
            if (mask & (1 << k)) continue;
            const cand = cur + w[j][k];
            const nmask = mask | (1 << k);
            if (cand < dp[nmask][k]) {
              dp[nmask][k] = cand;
              parent[nmask][k] = j;
            }
          }
        }
      }

      const full = size - 1;
      let end = 0;
      for (let j = 1; j < n; j++) if (dp[full][j] < dp[full][end]) end = j;

      const order = [];
      let mask = full;
      let j = end;
      while (j !== -1) {
        order.push(j);
        const pj = parent[mask][j];
        mask = mask & ~(1 << j);
        j = pj;
      }
      order.reverse();

      return { order, bestSeconds: dp[full][end] };
    }

    // ====== Minimalne testy (bez sieci) ======
    function assert(cond, msg) {
      if (!cond) throw new Error(msg || "assert failed");
    }

    function runLocalTests() {
      // Test normalizacji (ważne: żadnych surowych znaków nowej linii w literałach)
      assert(normalizeQuery("  ul.\t\r\nŚwidnicka   8  ") === "ul. Świdnicka 8", "normalizeQuery whitespace");
      assert(normalizeQuery("„Test”").includes('"Test"'), "normalizeQuery quotes");

      // Test bbox helpers
      const b = { south: 1, north: 2, west: 3, east: 4 };
      assert(boundsToPhotonBbox(b) === "3,1,4,2", "Photon bbox format");
      assert(boundsToNominatimViewbox(b) === "3,2,4,1", "Nominatim viewbox format");
      assert(withinBounds(1.5, 3.5, b) === true, "withinBounds inside");
      assert(withinBounds(5, 3.5, b) === false, "withinBounds outside");

      // Test solvera: preferuje 0->1->2
      const d = [
        [0, 1, 10],
        [1, 0, 1],
        [10, 1, 0],
      ];
      const { order } = solveOpenPathTsp(d, 0);
      assert(order.length === 3, "order length");
      assert(order[0] === 0, "fixed start respected");
      assert(order.join(",") === "0,1,2", "expected order 0,1,2");

      return true;
    }

    // ====== Mapa ======
    const map = L.map("map", { zoomControl: true });
    L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    const layerGroup = L.layerGroup().addTo(map);
    let routeLine = null;

    function clearMap() {
      layerGroup.clearLayers();
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }
    }

    function addMarkersAndRoute(stopsOrdered, lineCoords) {
      stopsOrdered.forEach((s, idx) => {
        const marker = L.marker([s.lat, s.lon]).addTo(layerGroup);
        marker.bindPopup(`<b>#${idx + 1}</b><br/>${escapeHtml(s.input)}<br/><small>${escapeHtml(s.display)}</small>`);
      });

      const latlngs = lineCoords.map(([lon, lat]) => [lat, lon]);
      routeLine = L.polyline(latlngs).addTo(map);
      map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // ====== Główna akcja ======
    async function run() {
      const city = normalizeQuery($("city").value);
      const addrLines = parseAddresses($("addresses").value).map(normalizeQuery);
      const geocoderMode = $("geocoder").value;
      const startMode = $("startMode").value;

      if (!city) {
        setStatus("Błąd: proszę podać miasto.");
        return;
      }
      if (addrLines.length < 2) {
        setStatus("Błąd: proszę podać co najmniej 2 adresy.");
        return;
      }

      clearMap();
      $("result").style.display = "none";

      btnRun.disabled = true;
      btnExample.disabled = true;

      try {
        setStatus("Ustalanie granic miasta (bbox)…");
        let cityBounds = null;
        try {
          cityBounds = await getCityBoundsNominatim(city);
        } catch (e) {
          console.warn("City bbox unavailable", e);
          cityBounds = null;
        }

        clearMap();
        if (cityBounds) {
          L.rectangle([[cityBounds.south, cityBounds.west], [cityBounds.north, cityBounds.east]], { weight: 1 }).addTo(layerGroup);
        }

        setStatus(`Geokodowanie: ${addrLines.length} adresów…`);

        const stops = [];
        for (let i = 0; i < addrLines.length; i++) {
          const input = addrLines[i];
          setStatus(`Geokodowanie (${i + 1}/${addrLines.length}): ${input}`);

          const g = await geocodeOne(input, city, geocoderMode, cityBounds);
          stops.push({
            input,
            display: g.display,
            lat: g.lat,
            lon: g.lon,
            provider: g.provider,
          });

          if (i < addrLines.length - 1) await sleep(GEOCODE_DELAY_MS);
        }

        setStatus("Pobieranie macierzy czasów pieszych (OSRM /table)…");
        const coords = stops.map(s => [s.lon, s.lat]);
        const table = await osrmTable(coords);

        const fixedStartIndex = (startMode === "fixed") ? 0 : null;
        setStatus("Optymalizacja kolejności (dokładnie)…");
        const { order } = solveOpenPathTsp(table.durations, fixedStartIndex);

        const stopsOrdered = order.map(idx => stops[idx]);
        const coordsOrdered = stopsOrdered.map(s => [s.lon, s.lat]);

        setStatus("Pobieranie geometrii trasy (OSRM /route)…");
        const route = await osrmRouteOrdered(coordsOrdered);

        addMarkersAndRoute(stopsOrdered, route.line);

        $("kpiTime").textContent = fmtTime(route.duration);
        $("kpiDist").textContent = fmtDist(route.distance);

        const ol = $("order");
        ol.innerHTML = "";
        for (const s of stopsOrdered) {
          const li = document.createElement("li");
          li.textContent = s.input;
          ol.appendChild(li);
        }

        $("result").style.display = "block";
        setStatus("Gotowe. Trasa została narysowana na mapie.");

      } catch (e) {
        console.error(e);
        setStatus(
          "Błąd: " + (e && e.message ? e.message : String(e)) +
          "\n\nJeżeli widzi Pan/Pani błąd typu CORS lub 429/403, to zwykle oznacza blokadę / limit usługi publicznej. " +
          "W takim przypadku proszę przełączyć geokoder na Nominatim lub użyć własnego backendu/proxy."
        );
      } finally {
        btnRun.disabled = false;
        btnExample.disabled = false;
      }
    }

    // ====== Przykład ======
    btnExample.addEventListener("click", () => {
      $("city").value = "Wrocław";
      $("addresses").value = [
        "Rynek 1",
        "plac Solny 1",
        "ul. Świdnicka 8",
        "ul. Piłsudskiego 105",
        "ul. Grodzka 11",
        "ul. Katedralna 4",
        "ul. Wita Stwosza 32",
        "ul. Kazimierza Wielkiego 35",
        "ul. Kuźnicza 21",
        "ul. Odrzańska 1",
      ].join("\n");
      setStatus("Wczytano przykład.");
    });

    btnRun.addEventListener("click", run);

    map.setView([51.11, 17.03], 13);

    // Uruchom minimalne testy lokalne (bez sieci)
    try {
      runLocalTests();
      console.info("Local tests: OK");
    } catch (e) {
      console.error("Local tests failed", e);
      setStatus("Uwaga: wewnętrzne testy lokalne nie przeszły. Sprawdź konsolę.");
    }
  </script>
</body>
</html>
