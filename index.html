<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Najkrótsza trasa piesza (OSM) — DOCX (TUTAY)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #ffffff;
      --fg: #0b0f19;
      --muted: rgba(11, 15, 25, 0.72);
      --muted2: rgba(11, 15, 25, 0.55);
      --line: rgba(11, 15, 25, 0.16);
      --panel: #ffffff;
      --inputBg: #ffffff;
      --inputFg: #0b0f19;
      --inputPh: rgba(11, 15, 25, 0.45);
      --btnBg: rgba(11, 15, 25, 0.06);
      --btnBgPrimary: rgba(0, 120, 255, 0.14);
      --btnFg: #0b0f19;
      --chipBg: rgba(11, 15, 25, 0.06);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0f19;
        --fg: #e8ecf7;
        --muted: rgba(232, 236, 247, 0.78);
        --muted2: rgba(232, 236, 247, 0.58);
        --line: rgba(232, 236, 247, 0.18);
        --panel: #0e1424;
        --inputBg: #0a1020;
        --inputFg: #e8ecf7;
        --inputPh: rgba(232, 236, 247, 0.45);
        --btnBg: rgba(232, 236, 247, 0.08);
        --btnBgPrimary: rgba(0, 120, 255, 0.24);
        --btnFg: #e8ecf7;
        --chipBg: rgba(232, 236, 247, 0.08);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .app {
      display: grid;
      grid-template-columns: 460px 1fr;
      height: 100vh;
    }

    .panel {
      padding: 16px;
      background: var(--panel);
      border-right: 1px solid var(--line);
      overflow: auto;
    }

    .map { height: 100vh; }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 12px 0 6px;
    }

    input[type="text"], input[type="file"], select, textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: var(--inputBg);
      color: var(--inputFg);
      outline: none;
    }

    input[type="file"] { padding: 8px 10px; }

    input[type="text"]::placeholder,
    textarea::placeholder {
      color: var(--inputPh);
    }

    textarea { min-height: 190px; resize: vertical; }

    .row { display: flex; gap: 10px; }
    .row > * { flex: 1; }

    .btnrow { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }

    button {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      background: var(--btnBg);
      color: var(--btnFg);
    }

    button.primary {
      background: var(--btnBgPrimary);
      border-color: rgba(0, 120, 255, 0.45);
    }

    button:disabled { opacity: .55; cursor: not-allowed; }

    .hint { font-size: 12px; color: var(--muted2); line-height: 1.4; margin-top: 8px; }

    .status {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--chipBg);
      font-size: 12px;
      white-space: pre-wrap;
      min-height: 44px;
      color: var(--fg);
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--chipBg);
      font-size: 12px;
      color: var(--muted);
    }

    .result {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--chipBg) 70%, transparent);
    }

    .result h3 { margin: 0 0 8px; font-size: 14px; color: var(--fg); }
    .result ol { margin: 0 0 0 18px; padding: 0; }
    .result li { margin: 6px 0; font-size: 13px; color: var(--fg); }

    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .kpi .box {
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--chipBg);
    }

    .kpi .label { font-size: 12px; color: var(--muted); margin: 0; }
    .kpi .value { font-size: 16px; margin: 4px 0 0; font-weight: 650; color: var(--fg); }

    .footer { margin-top: 14px; font-size: 12px; color: var(--muted2); line-height: 1.35; }

    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
      .panel { border-right: none; border-bottom: 1px solid var(--line); }
      .map { height: 60vh; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h2 style="margin:0 0 6px; font-size:16px;">Najkrótsza trasa piesza (OpenStreetMap)</h2>
      <div class="hint">
        Proszę wczytać dokument <span class="badge">DOCX</span> (formularz TUTAY).
        Aplikacja pobierze przystanki z pola <b>ADRES</b> (jeżeli brak — użyje pola <b>MIEJSCE</b> jako trybu zgodności) i automatycznie obliczy trasę.
      </div>

      <label for="docx">Wczytaj dokument DOCX (TUTAY)</label>
      <input id="docx" type="file" accept=".docx" multiple />
      <div class="hint">
        Na GitHub Pages (statycznie) nie wczytamy bezpośrednio Google Docs „.gdoc”. Proszę wyeksportować dokument do <b>.docx</b>.
      </div>

      <div class="row">
        <div>
          <label for="city">Miasto (z DOCX; można nadpisać)</label>
          <input id="city" type="text" placeholder="np. Wrocław" value="" />
        </div>
        <div>
          <label for="geocoder">Geokoder</label>
          <select id="geocoder">
            <option value="nominatim">Nominatim (OSM)</option>
            <option value="photon">Photon (komoot)</option>
            <option value="auto" selected>Auto (Nominatim → Photon)</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="startMode">Punkt startu</label>
          <select id="startMode">
            <option value="free" selected>Dowolny (najszybsza całość)</option>
            <option value="fixed">Pierwszy przystanek jako start</option>
          </select>
        </div>
        <div>
          <label for="previewCount">Liczba adresów</label>
          <input id="previewCount" type="text" value="0" readonly />
        </div>
      </div>

      <label for="preview">Podgląd wczytanych przystanków</label>
      <textarea id="preview" readonly placeholder="Po wczytaniu DOCX zostaną tu pokazane przystanki…"></textarea>

      <div class="btnrow">
        <button id="btnRecalc" class="primary" type="button" disabled>Przelicz trasę</button>
      </div>

      <div id="status" class="status">Gotowe. Proszę wczytać plik DOCX.</div>

      <div id="result" class="result" style="display:none;">
        <h3>Wynik</h3>
        <div class="kpi">
          <div class="box">
            <p class="label">Czas (pieszo)</p>
            <p id="kpiTime" class="value">—</p>
          </div>
          <div class="box">
            <p class="label">Dystans</p>
            <p id="kpiDist" class="value">—</p>
          </div>
        </div>
        <div style="margin-top: 10px;">
          <ol id="order"></ol>
        </div>
      </div>

      <div class="footer">
        Mapy: © OpenStreetMap contributors (ODbL). Routing i geokodowanie opierają się na usługach publicznych, które mogą ograniczać intensywne użycie.
      </div>
    </div>

    <div id="map" class="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>

  <script>
    // ====== Konfiguracja usług ======
    const NOMINATIM_BASE = "https://nominatim.openstreetmap.org";
    const PHOTON_BASE    = "https://photon.komoot.io";
    const OSRM_FOSSGIS_FOOT_BASE = "https://routing.openstreetmap.de/routed-foot";
    const OSRM_PROFILE = "walking";

    // Limity usług publicznych: geokodowanie ~1 żądanie/s.
    const GEOCODE_DELAY_MS = 1100;

    // ====== UI ======
    const $ = (id) => document.getElementById(id);
    const statusEl  = $("status");
    const docxInput = $("docx");
    const btnRecalc = $("btnRecalc");

    const state = { city: "", stops: [], busy: false };

    function setStatus(msg) { statusEl.textContent = msg; }
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    function setBusy(v) {
      state.busy = v;
      docxInput.disabled = v;
      btnRecalc.disabled = v || state.stops.length < 2;
    }

    function refreshPreview() {
      $("preview").value = state.stops.join("\n");
      $("previewCount").value = String(state.stops.length);
      btnRecalc.disabled = state.busy || state.stops.length < 2;
    }

    function fmtTime(sec) {
      if (!isFinite(sec)) return "—";
      sec = Math.max(0, Math.round(sec));
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      return h > 0 ? `${h}h ${String(m).padStart(2, "0")}m` : `${m}m`;
    }

    function fmtDist(meters) {
      if (!isFinite(meters)) return "—";
      return `${(meters / 1000).toFixed(2)} km`;
    }

    function normalizeQuery(s) {
      return String(s)
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .replace(/[ \t\r\n]+/g, " ")
        .trim();
    }

    function normalizeKey(k) { return normalizeQuery(k).toUpperCase(); }

    // ====== DOCX parsing (TUTAY) ======
    function splitMaybeKeyValue(line) {
      // Mammoth dla tabel często zwraca: "KLUCZ\tWARTOŚĆ".
      const parts = String(line).split("\t");
      if (parts.length >= 2) {
        return { ok: true, key: parts[0].trim(), value: parts.slice(1).join("\t").trim() };
      }
      return { ok: false, key: String(line).trim(), value: "" };
    }

    function cleanStopValue(v) {
      let t = normalizeQuery(v);
      t = t.replace(/^\d+\.[ ]*/, "");
      t = t.replace(/^[-•\u2022][ ]*/, "");
      return t.trim();
    }

    function extractCityAndStopsFromTutayText(rawText) {
      const lines = String(rawText).split(/\r?\n/).map(l => String(l).trim());
      let city = "";
      const byAdres = [];
      const byMiejsce = [];

      // 1) tryb tabelaryczny: KEY\tVALUE
      for (const line of lines) {
        const kv = splitMaybeKeyValue(line);
        if (!kv.ok) continue;
        const k = normalizeKey(kv.key);
        const v = cleanStopValue(kv.value);
        if (!city && k === "MIASTO") city = normalizeQuery(kv.value);
        if (k === "ADRES" && v) byAdres.push(v);
        if (k === "MIEJSCE" && v) byMiejsce.push(v);
      }

      // 2) tryb liniowy: KEY w linii, VALUE w kolejnej
      if (!city || (byAdres.length === 0 && byMiejsce.length === 0)) {
        for (let i = 0; i < lines.length; i++) {
          const k = normalizeKey(lines[i]);
          if (!city && k === "MIASTO") {
            i++;
            while (i < lines.length && !lines[i]) i++;
            if (i < lines.length) city = normalizeQuery(lines[i]);
            continue;
          }
          if (k === "ADRES" || k === "MIEJSCE") {
            const target = (k === "ADRES") ? byAdres : byMiejsce;
            i++;
            while (i < lines.length && !lines[i]) i++;
            if (i < lines.length) {
              const v = cleanStopValue(lines[i]);
              if (v) target.push(v);
            }
            continue;
          }
        }
      }

      // Preferuj ADRES, inaczej MIEJSCE (zgodność z starszymi dokumentami).
      const rawStops = (byAdres.length > 0) ? byAdres : byMiejsce;

      // Dedup
      const out = [];
      const seen = new Set();
      for (const s of rawStops) {
        const key = s.toLowerCase();
        if (!seen.has(key)) { seen.add(key); out.push(s); }
      }

      return { city, stops: out, mode: (byAdres.length > 0) ? "ADRES" : "MIEJSCE" };
    }

    async function loadDocxFiles(files) {
      if (!files || files.length === 0) return;
      if (typeof mammoth === "undefined" || !mammoth.extractRawText) {
        throw new Error("Brak biblioteki DOCX (mammoth). Proszę odświeżyć stronę.");
      }

      const allStops = [];
      const cities = new Set();
      const modes = new Set();

      for (let idx = 0; idx < files.length; idx++) {
        const f = files[idx];
        if (!f.name.toLowerCase().endsWith(".docx")) continue;

        setStatus(`Wczytywanie DOCX (${idx + 1}/${files.length}): ${f.name}`);
        const buf = await f.arrayBuffer();
        const res = await mammoth.extractRawText({ arrayBuffer: buf });
        const rawText = (res && res.value) ? res.value : "";

        const parsed = extractCityAndStopsFromTutayText(rawText);
        if (parsed.city) cities.add(parsed.city);
        if (parsed.mode) modes.add(parsed.mode);
        for (const s of (parsed.stops || [])) allStops.push(s);
      }

      const uniqueCities = Array.from(cities).filter(Boolean);
      if (uniqueCities.length > 1) {
        throw new Error(`Wczytano dokumenty z różnymi miastami: ${uniqueCities.join(", ")}. Proszę użyć jednego miasta.`);
      }

      const city = uniqueCities[0] || "";
      if (city) {
        $("city").value = city;
        state.city = city;
      } else {
        state.city = normalizeQuery($("city").value);
      }

      // Dedup global
      const out = [];
      const seen = new Set();
      for (const s of allStops) {
        const key = s.toLowerCase();
        if (!seen.has(key)) { seen.add(key); out.push(s); }
      }

      if (!state.city) throw new Error("Brak pola MIASTO w dokumencie (lub pole jest puste)." );
      if (out.length === 0) throw new Error("Nie znaleziono żadnych przystanków w polu ADRES ani MIEJSCE." );

      state.stops = (out.length > 12) ? out.slice(0, 12) : out;
      refreshPreview();

      const used = (modes.has("ADRES")) ? "ADRES" : "MIEJSCE";
      if (out.length > 12) {
        setStatus(`Wczytano ${out.length} przystanków (użyto: ${used}). Do obliczeń użyto pierwszych 12.`);
      } else {
        setStatus(`Wczytano ${out.length} przystanków (użyto: ${used}).`);
      }
    }

    // ====== Geokodowanie ======
    function withinBounds(lat, lon, bounds) {
      if (!bounds) return true;
      const { south, north, west, east } = bounds;
      return lat >= south && lat <= north && lon >= west && lon <= east;
    }

    function boundsToPhotonBbox(bounds) {
      // Photon: bbox=minLon,minLat,maxLon,maxLat
      return `${bounds.west},${bounds.south},${bounds.east},${bounds.north}`;
    }

    function boundsToNominatimViewbox(bounds) {
      // Nominatim: viewbox=left,top,right,bottom => west,north,east,south
      return `${bounds.west},${bounds.north},${bounds.east},${bounds.south}`;
    }

    async function safeReadJson(resp) {
      const ct = (resp.headers.get("content-type") || "").toLowerCase();
      try {
        if (ct.includes("application/json")) return await resp.json();
        return { _text: await resp.text() };
      } catch {
        return { _readError: true };
      }
    }

    async function getCityBoundsNominatim(city) {
      const c = normalizeQuery(city);
      const url = new URL(NOMINATIM_BASE + "/search");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("limit", "1");
      url.searchParams.set("q", c);

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.error || body.message || body._text) ? ` | ${body.error || body.message || body._text}` : "";
        throw new Error(`Nominatim(city) HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      if (!Array.isArray(data) || data.length === 0) throw new Error("Nominatim(city): brak wyników");

      const top = data[0];
      const bb = top.boundingbox;
      if (!Array.isArray(bb) || bb.length !== 4) throw new Error("Nominatim(city): brak boundingbox");

      // jsonv2: [south, north, west, east]
      const south = parseFloat(bb[0]);
      const north = parseFloat(bb[1]);
      const west  = parseFloat(bb[2]);
      const east  = parseFloat(bb[3]);

      if (![south, north, west, east].every(v => Number.isFinite(v))) {
        throw new Error("Nominatim(city): nieprawidłowy boundingbox");
      }
      return { south, north, west, east };
    }

    async function geocodeNominatim(query, bounds) {
      const q = normalizeQuery(query);
      if (!q) throw new Error("Nominatim: pusty query");

      const url = new URL(NOMINATIM_BASE + "/search");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("limit", "1");
      url.searchParams.set("q", q);

      if (bounds) {
        url.searchParams.set("viewbox", boundsToNominatimViewbox(bounds));
        url.searchParams.set("bounded", "1");
      }

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.error || body.message || body._text) ? ` | ${body.error || body.message || body._text}` : "";
        throw new Error(`Nominatim HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      if (!Array.isArray(data) || data.length === 0) throw new Error("Nominatim: brak wyników");

      const top = data[0];
      const out = { provider: "nominatim", display: top.display_name || q, lat: parseFloat(top.lat), lon: parseFloat(top.lon) };
      if (bounds && !withinBounds(out.lat, out.lon, bounds)) throw new Error("Nominatim: wynik poza granicami miasta");
      return out;
    }

    async function geocodePhoton(query, bounds) {
      const q = normalizeQuery(query);
      if (!q) throw new Error("Photon: pusty query");

      const url = new URL(PHOTON_BASE + "/api/");
      url.searchParams.set("q", q);
      url.searchParams.set("limit", "1");
      if (bounds) url.searchParams.set("bbox", boundsToPhotonBbox(bounds));

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const msg = body && (body.message || body.error || body._text) ? (body.message || body.error || body._text) : "";
        throw new Error(`Photon HTTP ${resp.status}${msg ? " | " + msg : ""}`);
      }
      const data = await resp.json();

      const f = (data && data.features && data.features[0]) || null;
      if (!f || !f.geometry || !Array.isArray(f.geometry.coordinates)) throw new Error("Photon: brak wyników");

      const [lon, lat] = f.geometry.coordinates;
      const props = f.properties || {};
      const display = [props.name, props.street, props.city, props.country].filter(Boolean).join(", ") || q;

      const out = { provider: "photon", display, lat: parseFloat(lat), lon: parseFloat(lon) };
      if (bounds && !withinBounds(out.lat, out.lon, bounds)) throw new Error("Photon: wynik poza granicami miasta");
      return out;
    }

    async function geocodeAuto(query, bounds) {
      try { return await geocodeNominatim(query, bounds); }
      catch (e1) {
        try { return await geocodePhoton(query, bounds); }
        catch (e2) {
          throw new Error(
            `Geokodowanie nie powiodło się (Nominatim + Photon).\n` +
            `- Nominatim: ${e1 && e1.message ? e1.message : String(e1)}\n` +
            `- Photon: ${e2 && e2.message ? e2.message : String(e2)}`
          );
        }
      }
    }

    async function geocodeOne(stopLine, city, mode, bounds) {
      const a = normalizeQuery(stopLine);
      const c = normalizeQuery(city);

      const mk = (x) => {
        const t = normalizeQuery(x);
        return t.toLowerCase().includes(c.toLowerCase()) ? t : `${t}, ${c}`;
      };

      const attempt = async (q) => {
        if (mode === "nominatim") return await geocodeNominatim(q, bounds);
        if (mode === "photon") return await geocodePhoton(q, bounds);
        return await geocodeAuto(q, bounds);
      };

      // 1) pełna linia
      try { return await attempt(mk(a)); }
      catch (e1) {
        // 2) jedna próba uproszczona
        const alt = normalizeQuery(a.split(" – ")[0].split(" - ")[0]);
        if (alt && alt !== a) {
          try { return await attempt(mk(alt)); }
          catch (e2) {
            throw new Error(`Nie udało się zgeokodować: "${a}"\n- Próba pełna: ${e1.message || e1}\n- Próba uproszczona: ${e2.message || e2}`);
          }
        }
        throw new Error(`Nie udało się zgeokodować: "${a}"\n- Błąd: ${e1.message || e1}`);
      }
    }

    // ====== OSRM (macierz + trasa) ======
    async function osrmTable(coordsLonLat) {
      const coordStr = coordsLonLat.map(([lon, lat]) => `${lon.toFixed(6)},${lat.toFixed(6)}`).join(";");
      const url = new URL(`${OSRM_FOSSGIS_FOOT_BASE}/table/v1/${OSRM_PROFILE}/${coordStr}`);
      url.searchParams.set("annotations", "duration,distance");

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.message || body._text) ? ` | ${body.message || body._text}` : "";
        throw new Error(`OSRM /table HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      if (!data || !Array.isArray(data.durations)) throw new Error("OSRM: brak macierzy durations");
      return data;
    }

    async function osrmRouteOrdered(coordsLonLat) {
      const coordStr = coordsLonLat.map(([lon, lat]) => `${lon.toFixed(6)},${lat.toFixed(6)}`).join(";");
      const url = new URL(`${OSRM_FOSSGIS_FOOT_BASE}/route/v1/${OSRM_PROFILE}/${coordStr}`);
      url.searchParams.set("overview", "full");
      url.searchParams.set("geometries", "geojson");
      url.searchParams.set("steps", "false");

      const resp = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
      if (!resp.ok) {
        const body = await safeReadJson(resp);
        const extra = body && (body.message || body._text) ? ` | ${body.message || body._text}` : "";
        throw new Error(`OSRM /route HTTP ${resp.status}${extra}`);
      }
      const data = await resp.json();
      const r = (data && data.routes && data.routes[0]) || null;
      if (!r || !r.geometry || !Array.isArray(r.geometry.coordinates)) throw new Error("OSRM: brak geometrii trasy");
      return { distance: r.distance, duration: r.duration, line: r.geometry.coordinates };
    }

    // ====== Optymalizacja kolejności (DP TSP, ścieżka bez powrotu) ======
    function solveOpenPathTsp(durations, fixedStartIndex) {
      const n = durations.length;
      const INF = 1e18;

      const w = Array.from({ length: n }, (_, i) =>
        Array.from({ length: n }, (_, j) => {
          const v = durations[i][j];
          if (i === j) return 0;
          if (v === null || v === undefined) return INF;
          return Number(v);
        })
      );

      const size = 1 << n;
      const dp = Array.from({ length: size }, () => new Float64Array(n).fill(INF));
      const parent = Array.from({ length: size }, () => new Int16Array(n).fill(-1));

      if (fixedStartIndex === null) {
        for (let i = 0; i < n; i++) dp[1 << i][i] = 0;
      } else {
        dp[1 << fixedStartIndex][fixedStartIndex] = 0;
      }

      for (let mask = 0; mask < size; mask++) {
        for (let j = 0; j < n; j++) {
          const cur = dp[mask][j];
          if (!(cur < INF)) continue;
          for (let k = 0; k < n; k++) {
            if (mask & (1 << k)) continue;
            const cand = cur + w[j][k];
            const nmask = mask | (1 << k);
            if (cand < dp[nmask][k]) {
              dp[nmask][k] = cand;
              parent[nmask][k] = j;
            }
          }
        }
      }

      const full = size - 1;
      let end = 0;
      for (let j = 1; j < n; j++) if (dp[full][j] < dp[full][end]) end = j;

      const order = [];
      let mask = full;
      let j = end;
      while (j !== -1) {
        order.push(j);
        const pj = parent[mask][j];
        mask = mask & ~(1 << j);
        j = pj;
      }
      order.reverse();

      return { order, bestSeconds: dp[full][end] };
    }

    // ====== Mapa ======
    const map = L.map("map", { zoomControl: true });
    L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    const layerGroup = L.layerGroup().addTo(map);
    let routeLine = null;

    function clearMap() {
      layerGroup.clearLayers();
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function addMarkersAndRoute(stopsOrdered, lineCoords) {
      stopsOrdered.forEach((s, idx) => {
        const marker = L.marker([s.lat, s.lon]).addTo(layerGroup);
        marker.bindPopup(`<b>#${idx + 1}</b><br/>${escapeHtml(s.input)}<br/><small>${escapeHtml(s.display)}</small>`);
      });

      const latlngs = lineCoords.map(([lon, lat]) => [lat, lon]);
      routeLine = L.polyline(latlngs).addTo(map);
      map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });
    }

    // ====== Obliczenia ======
    async function computeRoute() {
      state.city = normalizeQuery($("city").value) || state.city;
      const city = normalizeQuery(state.city);
      const stopLines = (state.stops || []).map(normalizeQuery).filter(Boolean);
      const geocoderMode = $("geocoder").value;
      const startMode = $("startMode").value;

      if (!city) { setStatus("Błąd: brak miasta."); return; }
      if (stopLines.length < 2) { setStatus("Błąd: wymagane są co najmniej 2 przystanki."); return; }

      clearMap();
      $("result").style.display = "none";

      setBusy(true);
      try {
        setStatus("Ustalanie granic miasta (bbox)…");
        const cityBounds = await getCityBoundsNominatim(city);

        clearMap();
        L.rectangle([[cityBounds.south, cityBounds.west], [cityBounds.north, cityBounds.east]], { weight: 1 }).addTo(layerGroup);

        setStatus(`Geokodowanie: ${stopLines.length} przystanków…`);
        const stops = [];
        for (let i = 0; i < stopLines.length; i++) {
          const input = stopLines[i];
          setStatus(`Geokodowanie (${i + 1}/${stopLines.length}): ${input}`);
          const g = await geocodeOne(input, city, geocoderMode, cityBounds);
          stops.push({ input, display: g.display, lat: g.lat, lon: g.lon, provider: g.provider });
          if (i < stopLines.length - 1) await sleep(GEOCODE_DELAY_MS);
        }

        setStatus("Pobieranie macierzy czasów pieszych (OSRM /table)…");
        const coords = stops.map(s => [s.lon, s.lat]);
        const table = await osrmTable(coords);

        setStatus("Optymalizacja kolejności…");
        const fixedStartIndex = (startMode === "fixed") ? 0 : null;
        const { order } = solveOpenPathTsp(table.durations, fixedStartIndex);

        const stopsOrdered = order.map(idx => stops[idx]);
        const coordsOrdered = stopsOrdered.map(s => [s.lon, s.lat]);

        setStatus("Pobieranie geometrii trasy (OSRM /route)…");
        const route = await osrmRouteOrdered(coordsOrdered);

        addMarkersAndRoute(stopsOrdered, route.line);

        $("kpiTime").textContent = fmtTime(route.duration);
        $("kpiDist").textContent = fmtDist(route.distance);

        const ol = $("order");
        ol.innerHTML = "";
        for (const s of stopsOrdered) {
          const li = document.createElement("li");
          li.textContent = s.input;
          ol.appendChild(li);
        }

        $("result").style.display = "block";
        setStatus("Gotowe. Trasa została narysowana na mapie.");
      } catch (e) {
        console.error(e);
        setStatus("Błąd: " + (e && e.message ? e.message : String(e)));
      } finally {
        setBusy(false);
      }
    }

    // ====== Minimalne testy lokalne (bez sieci) ======
    function assert(cond, msg) { if (!cond) throw new Error(msg || "assert failed"); }

    function runLocalTests() {
      assert(normalizeQuery("  ul.\t\r\nŚwidnicka   8  ") === "ul. Świdnicka 8", "normalizeQuery whitespace");

      const sampleTab = [
        "MIASTO\tWrocław",
        "MIEJSCE\t1. Rynek – przy Ratuszu",
        "MIEJSCE\t2. Pręgierz – Rynek",
      ].join("\n");
      const p1 = extractCityAndStopsFromTutayText(sampleTab);
      assert(p1.city === "Wrocław", "parse city tab");
      assert(p1.stops.length === 2, "parse stops tab count");

      const sampleAdres = [
        "MIASTO\tWrocław",
        "ADRES\t1. Rynek 1",
        "ADRES\t2. Kurzy Targ 4",
      ].join("\n");
      const p2 = extractCityAndStopsFromTutayText(sampleAdres);
      assert(p2.mode === "ADRES", "prefer ADRES");
      assert(p2.stops[0] === "Rynek 1", "clean numbering" );

      const d = [
        [0, 1, 10],
        [1, 0, 1],
        [10, 1, 0],
      ];
      const { order } = solveOpenPathTsp(d, 0);
      assert(order.join(",") === "0,1,2", "tsp order");
      return true;
    }

    // ====== Zdarzenia ======
    docxInput.addEventListener("change", async () => {
      const files = Array.from(docxInput.files || []);
      if (files.length === 0) return;

      setBusy(true);
      try {
        await loadDocxFiles(files);
        await computeRoute(); // wymaganie: licz trasę automatycznie po dodaniu pliku
      } catch (e) {
        console.error(e);
        setStatus("Błąd przy wczytywaniu DOCX: " + (e && e.message ? e.message : String(e)));
      } finally {
        setBusy(false);
      }
    });

    btnRecalc.addEventListener("click", computeRoute);

    map.setView([51.11, 17.03], 13);

    try {
      runLocalTests();
      console.info("Local tests: OK");
    } catch (e) {
      console.error("Local tests failed", e);
      setStatus("Uwaga: wewnętrzne testy lokalne nie przeszły. Proszę sprawdzić konsolę.");
    }
  </script>
</body>
</html>
